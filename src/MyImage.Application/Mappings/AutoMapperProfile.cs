namespace MyImage.Application.Mappings;

/// <summary>
/// AutoMapper profile for configuring object-to-object mappings.
/// This profile defines how domain entities are converted to DTOs and vice versa,
/// ensuring clean separation between layers while reducing boilerplate mapping code.
/// It handles complex property mappings and nested object conversions automatically.
/// </summary>
public class AutoMapperProfile : Profile
{
    /// <summary>
    /// Initializes the AutoMapper profile with all entity-to-DTO mappings.
    /// Configures bidirectional mappings between domain entities and their corresponding DTOs
    /// while handling complex property transformations and nested object mappings.
    /// </summary>
    public AutoMapperProfile()
    {
        // Configure User entity mappings
        ConfigureUserMappings();

        // Configure Photo entity mappings
        ConfigurePhotoMappings();

        // Configure Address entity mappings
        ConfigureAddressMappings();
    }

    /// <summary>
    /// Configures mapping between User entity and authentication DTOs.
    /// Handles the conversion between the rich User domain entity and the
    /// simplified DTOs used for authentication responses and API communication.
    /// </summary>
    private void ConfigureUserMappings()
    {
        // User to AuthResponseDto mapping
        CreateMap<User, AuthResponseDto>()
            .ForMember(dest => dest.UserId, opt => opt.MapFrom(src => src.Id))
            .ForMember(dest => dest.FirstName, opt => opt.MapFrom(src => src.Profile.FirstName))
            .ForMember(dest => dest.LastName, opt => opt.MapFrom(src => src.Profile.LastName))
            .ForMember(dest => dest.Token, opt => opt.Ignore()) // Set manually in service
            .ForMember(dest => dest.RefreshToken, opt => opt.Ignore()) // Set manually in service
            .ForMember(dest => dest.ExpiresIn, opt => opt.Ignore()) // Set manually in service
            .ForMember(dest => dest.IssuedAt, opt => opt.Ignore()); // Set manually in service

        // RegisterRequestDto to User mapping
        CreateMap<RegisterRequestDto, User>()
            .ForMember(dest => dest.Id, opt => opt.Ignore()) // Generated by MongoDB
            .ForMember(dest => dest.Email, opt => opt.MapFrom(src => src.Email.ToLowerInvariant()))
            .ForMember(dest => dest.PasswordHash, opt => opt.Ignore()) // Set manually in service
            .ForMember(dest => dest.EmailVerified, opt => opt.MapFrom(src => false))
            .ForMember(dest => dest.EmailVerificationToken, opt => opt.Ignore()) // Set manually in service
            .ForMember(dest => dest.Profile, opt => opt.MapFrom(src => new UserProfile
            {
                FirstName = src.FirstName.Trim(),
                LastName = src.LastName.Trim(),
                DisplayName = $"{src.FirstName.Trim()} {src.LastName.Trim()[0]}.",
                PhoneNumber = src.PhoneNumber?.Trim()
            }))
            .ForMember(dest => dest.Roles, opt => opt.MapFrom(src => new List<string> { "customer" }))
            .ForMember(dest => dest.Metadata, opt => opt.MapFrom(src => new UserMetadata
            {
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow,
                AccountStatus = "active",
                RegistrationSource = "web"
            }));
    }

    /// <summary>
    /// Configures mapping between Photo entity and photo management DTOs.
    /// Handles the conversion between the comprehensive Photo domain entity and various
    /// DTOs used for different photo operations like gallery display and detailed views.
    /// </summary>
    private void ConfigurePhotoMappings()
    {
        // Photo to PhotoDto mapping (basic photo information for lists)
        CreateMap<Photo, PhotoDto>()
            .ForMember(dest => dest.Filename, opt => opt.MapFrom(src => src.FileInfo.OriginalFilename))
            .ForMember(dest => dest.FileSize, opt => opt.MapFrom(src => src.FileInfo.FileSize))
            .ForMember(dest => dest.UploadedAt, opt => opt.MapFrom(src => src.FileInfo.UploadedAt))
            .ForMember(dest => dest.ThumbnailUrl, opt => opt.MapFrom(src =>
                src.Storage.Urls.GetValueOrDefault("thumbnail", string.Empty)))
            .ForMember(dest => dest.PreviewUrl, opt => opt.MapFrom(src =>
                src.Storage.Urls.GetValueOrDefault("medium", string.Empty)))
            .ForMember(dest => dest.Dimensions, opt => opt.MapFrom(src => new PhotoDimensionsDto
            {
                Width = src.ImageData.Width,
                Height = src.ImageData.Height,
                AspectRatio = src.ImageData.AspectRatio,
                Orientation = src.ImageData.Orientation
            }))
            .ForMember(dest => dest.ProcessingStatus, opt => opt.MapFrom(src => src.Processing.Status))
            .ForMember(dest => dest.IsFavorite, opt => opt.MapFrom(src => src.Flags.IsFavorite))
            .ForMember(dest => dest.PrintCount, opt => opt.MapFrom(src => src.PrintHistory.Count));

        // Photo to PhotoDetailsDto mapping (comprehensive photo information)
        CreateMap<Photo, PhotoDetailsDto>()
            .IncludeBase<Photo, PhotoDto>() // Include all mappings from PhotoDto
            .ForMember(dest => dest.OriginalUrl, opt => opt.MapFrom(src =>
                src.Storage.Urls.GetValueOrDefault("original", string.Empty)))
            .ForMember(dest => dest.MimeType, opt => opt.MapFrom(src => src.FileInfo.MimeType))
            .ForMember(dest => dest.TechnicalDetails, opt => opt.MapFrom(src => new PhotoTechnicalDetailsDto
            {
                Dpi = src.ImageData.Dpi,
                ColorSpace = src.ImageData.ColorSpace,
                HasTransparency = src.ImageData.HasTransparency,
                QualityScore = src.AIAnalysis != null ? src.AIAnalysis.Quality?.Score ?? 0 : 0
            }))
            .ForMember(dest => dest.ExifData, opt => opt.MapFrom(src => src.ExifData))
            .ForMember(dest => dest.PrintHistory, opt => opt.MapFrom(src => src.PrintHistory))
            .ForMember(dest => dest.AiAnalysis, opt => opt.MapFrom(src => src.AIAnalysis))
            .ForMember(dest => dest.AvailableEnhancements, opt => opt.MapFrom(src =>
                src.Processing.AiEnhancementAvailable ? new List<string> { "color_correction", "noise_reduction" } : new List<string>()))
            .ForMember(dest => dest.RecommendedPrintSizes, opt => opt.MapFrom(src =>
                CalculateRecommendedPrintSizes(src.ImageData.Width, src.ImageData.Height)));

        // PhotoExifData to PhotoExifDto mapping
        CreateMap<PhotoExifData, PhotoExifDto>()
            .ForMember(dest => dest.Camera, opt => opt.MapFrom(src =>
                src.Camera != null ? $"{src.Camera.Make} {src.Camera.Model}" : null))
            .ForMember(dest => dest.Lens, opt => opt.MapFrom(src => src.Camera != null ? src.Camera.Lens : null))
            .ForMember(dest => dest.Iso, opt => opt.MapFrom(src => src.Settings != null ? src.Settings.Iso : null))
            .ForMember(dest => dest.Aperture, opt => opt.MapFrom(src => src.Settings != null ? src.Settings.Aperture : null))
            .ForMember(dest => dest.ShutterSpeed, opt => opt.MapFrom(src => src.Settings != null ? src.Settings.ShutterSpeed : null))
            .ForMember(dest => dest.FocalLength, opt => opt.MapFrom(src => src.Settings != null ? src.Settings.FocalLength : null))
            .ForMember(dest => dest.TakenAt, opt => opt.MapFrom(src => src.Timestamp));

        // PhotoPrintRecord to PhotoPrintHistoryDto mapping
        CreateMap<PhotoPrintRecord, PhotoPrintHistoryDto>()
            .ForMember(dest => dest.OrderNumber, opt => opt.Ignore()) // Would need to join with Order data
            .ForMember(dest => dest.OrderDate, opt => opt.MapFrom(src => src.PrintedAt))
            .ForMember(dest => dest.Finish, opt => opt.Ignore()); // Would need to get from order details

        // PhotoAIAnalysis to PhotoAIAnalysisDto mapping
        CreateMap<PhotoAIAnalysis, PhotoAIAnalysisDto>()
            .ForMember(dest => dest.SceneTypes, opt => opt.MapFrom(src => src.SceneType))
            .ForMember(dest => dest.QualityScore, opt => opt.MapFrom(src => src.Quality != null ? src.Quality.Score : 0))
            .ForMember(dest => dest.QualityAssessments, opt => opt.MapFrom(src =>
                src.Quality != null ? new Dictionary<string, string>
                {
                    ["sharpness"] = src.Quality.Sharpness,
                    ["exposure"] = src.Quality.Exposure
                } : new Dictionary<string, string>()))
            .ForMember(dest => dest.Suggestions, opt => opt.MapFrom(src =>
                src.Quality != null ? src.Quality.Suggestions : new List<string>()));

        // PhotoUploadDto to Photo mapping (partial, used during upload)
        CreateMap<PhotoUploadDto, Photo>()
            .ForMember(dest => dest.Tags, opt => opt.MapFrom(src => ParseTags(src.Tags)))
            .ForMember(dest => dest.UserNotes, opt => opt.MapFrom(src => src.Notes))
            .ForMember(dest => dest.Flags, opt => opt.MapFrom(src => new PhotoFlags
            {
                IsPrivate = src.IsPrivate
            }))
            .ForAllOtherMembers(opt => opt.Ignore()); // Other properties set manually during upload
    }

    /// <summary>
    /// Configures mapping between Address entity and address DTOs.
    /// Handles the conversion between address entities used in user profiles
    /// and DTOs used for API communication and form handling.
    /// </summary>
    private void ConfigureAddressMappings()
    {
        // Simple mapping for Address entities (embedded in User)
        CreateMap<Address, Address>(); // Identity mapping for updates
    }

    /// <summary>
    /// Helper method to calculate recommended print sizes based on image dimensions.
    /// Analyzes image resolution to determine which print sizes will produce high-quality results.
    /// Uses industry-standard DPI requirements for different print sizes.
    /// </summary>
    /// <param name="width">Image width in pixels</param>
    /// <param name="height">Image height in pixels</param>
    /// <returns>List of recommended print size codes</returns>
    private static List<string> CalculateRecommendedPrintSizes(int width, int height)
    {
        var recommendedSizes = new List<string>();
        var minDimension = Math.Min(width, height);
        var maxDimension = Math.Max(width, height);

        // Calculate recommended sizes based on 300 DPI requirement
        // These are conservative estimates to ensure good print quality
        if (minDimension >= 1800 && maxDimension >= 1200) recommendedSizes.Add("4x6");
        if (minDimension >= 2100 && maxDimension >= 1500) recommendedSizes.Add("5x7");
        if (minDimension >= 3000 && maxDimension >= 2400) recommendedSizes.Add("8x10");
        if (minDimension >= 3300 && maxDimension >= 2550) recommendedSizes.Add("9x12");
        if (minDimension >= 4200 && maxDimension >= 3300) recommendedSizes.Add("11x14");
        if (minDimension >= 4800 && maxDimension >= 3600) recommendedSizes.Add("12x18");
        if (minDimension >= 6000 && maxDimension >= 4800) recommendedSizes.Add("16x20");

        // If no standard sizes are recommended, at least recommend wallet size
        if (!recommendedSizes.Any() && minDimension >= 600 && maxDimension >= 900)
        {
            recommendedSizes.Add("wallet");
        }

        return recommendedSizes;
    }

    /// <summary>
    /// Helper method to parse comma-separated tags string into a list.
    /// Cleans up tag input by trimming whitespace, converting to lowercase,
    /// removing duplicates, and filtering out empty tags.
    /// </summary>
    /// <param name="tagsString">Comma-separated tags string</param>
    /// <returns>Clean list of unique tags</returns>
    private static List<string> ParseTags(string? tagsString)
    {
        if (string.IsNullOrWhiteSpace(tagsString))
            return new List<string>();

        return tagsString.Split(',', StringSplitOptions.RemoveEmptyEntries)
            .Select(tag => tag.Trim().ToLowerInvariant())
            .Where(tag => !string.IsNullOrEmpty(tag))
            .Distinct()
            .ToList();
    }
}